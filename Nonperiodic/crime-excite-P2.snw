
<< >>=

if(!file.exists("Excite.Spatail.Marks")){system("mkdir Excite.Spatail.Marks")}

for(i in 1:nrow(a)){
     fn <- paste("Excite.Spatail.Marks/crime1-",substr(10000+i,2,5),".mark",sep="")
     if(!file.exists(fn)){
         print(i)
         excite.spatial.mark.temp <- matrix((inpoly(excite.spatial.basex +a$coorx[i], excite.spatial.basey + a$coory[i], city.boundary$x, city.boundary$y) >=0),
         ncol=length(excite.spatial.base.x))
         save(excite.spatial.mark.temp, file=fn)
     }
}
@ 

Since the size of matrix \texttt{excite.spatial.mark.temp} is 
$2001\times 2001$, it is difficult to store them in one array with a size of
$2001\times 2001 \times 5087=20,368,353,087$. Thus we put them into files and read them with function \texttt{Vm} when neccessary.
<<>>=
Vm <- function(fn){
  load(paste("Excite.Spatail.Marks/",fn,sep=""))
  excite.spatial.mark.temp
}
@ 

\begin{figure}
<<fig=TRUE>>=
kk <- as.integer(runif(1, 1, nrow(a)+1))
 plot(excite.spatial.basex[seq(1, length(excite.spatial.base.x), 20), seq(1, length(excite.spatial.base.y), 20)], 
      excite.spatial.basey[seq(1, length(excite.spatial.base.x), 20), seq(1, length(excite.spatial.base.x),20)], col=Vm(paste("crime1-",substr(kk+10000,2,5), ".mark",sep=""))[seq(1, length(excite.spatial.base.x), 20), seq(1, length(excite.spatial.base.y), 20)]+2, pch=".", main=paste(kk, "Coverage"),cex=4, xlab="X", ylab="Y")

@ 
<<>>=
 plot(excite.spatial.basex[seq(1, length(excite.spatial.base.x), 20), seq(1, length(excite.spatial.base.y), 20)], excite.spatial.basey[seq(1, length(excite.spatial.base.x), 20), seq(1, length(excite.spatial.base.y), 20)], 
      col=Vm(paste("crime1-",substr(kk+10000,2,5), ".mark",sep=""))+2, 
      pch=".", main=kk)
@ 
\end{figure}

Now, we go into the iteration steps. First, to reconstruct all the component functions. 

(a) Contruct daily peridicity.
<<eval=TRUE>>=
   lambda.at.events <- mu * bgrates.at.events.no.mu + A * triggers.at.events.no.A
   bgprobs <- mu * bgrates.at.events.no.mu / lambda.at.events

@ 
<<eval=TRUE,fig=TRUE>>=

### 2-1. smoothing daily 
print("### 2-1. smoothing daily ")

@ 
(b) Construct weekly
<<eval=TRUE,fig=TRUE>>=

print("### 2-2. smoothing weekly")


@ 
(c) Construct trend
<<eval=TRUE,fig=TRUE>>=

print("### 2-3. smoothing  trend")
wghs.trend <- trend.fun(a$days)/lambda.at.events

trend.basevalue <- rep(0, length(time.marks))

for(i in 1:nrow(a)){
    trend.basevalue <- (trend.basevalue + wghs.trend[i]*dnorm(a$days[i]-time.marks, 0, 100)/(pnorm(TT, a$days[i], 100)-pnorm(0, a$days[i],  100)))    
}

trend.basevalue <- trend.basevalue/mean(trend.basevalue)

plot(time.marks, trend.basevalue, type="l")

@ 

(d) Smoothing background

<<>>=

# wghs.background <- bgprobs

background.basevalue <- matrix(0, nrow=length(background.base$x), 
   ncol=length(background.base$y))

if(!file.exists("Background.Smoothers"))system("mkdir Background.Smoothers")

for(i in 1:nrow(a)){
    
    fn <- paste("Background.Smoothers/", "bgsmoother-",i,".val", sep="")
   if(!file.exists(fn)){
       
       bgsmoother <- dnorm(background.basex, 
                           a$coorx[i], a$bandwidth[i])* dnorm(background.basey,
                           a$coory[i], a$bandwidth[i])/a$bg.integral[i]
       save(bgsmoother,file=fn)
    } else{
        load(fn)
    }   
   background.basevalue <- background.basevalue + bgprobs[i]*bgsmoother
    
  if(i/500 ==as.integer(i/500)| i == nrow(a)){# print(i)
   filled.contour(background.base$x[seq(1, length(background.base$x), 18)],background.base$y[seq(1, length(background.base$y), 18)],
     (log10(background.basevalue*(background.marks>=0)/730/
               polyarea(city.boundary$x, city.boundary$y)))[seq(1, length(background.base$x), 18),seq(1, length(background.base$y), 18)], main=i)
  }
}
 
### Standardize the background so its average is 1
   background.basevalue <-  background.basevalue/mean(background.basevalue[background.marks>=0])
@

(e) Construct temporal excitations.
<<eval=TRUE,fig=TRUE>>=


excite.temporal.base <- seq(0, 15, 0.005)    
excite.spatial.basex <- excite.spatial.base.x %o% rep(1, length(excite.spatial.base.y))
excite.spatial.basey<- rep(1, length(excite.spatial.base.x)) %o% excite.spatial.base.y


temporal.repetance <- 0 * excite.temporal.base
spatial.repetance <- matrix(0, ncol=length(excite.spatial.base.x),
                            nrow=length(excite.spatial.base.y))  

excite.temporal.edge.correction <- rep(0, nrow(a))
excite.spatial.edge.correction <- rep(0, nrow(a))

for(i in 1:nrow(a)){
#     print(i)
    excite.temporal.edge.correction[i] <-sum(excite.temporal.fun(seq(0, TT-a$days[i], 0.005)+0.6e-5))*.005
       
    temporal.repetance [excite.temporal.base < TT -a$days[i]] <- temporal.repetance [excite.temporal.base < TT -a$days[i]]+1  
    
   
    temp <- Vm(paste("crime1-",substr(i+10000,2,5), ".mark", sep=""))
         
    spatial.repetance <- spatial.repetance + temp
          
    excite.spatial.edge.correction [i] <- simpson.2D(temp*excite.spatial.basevalue, 0.002, 0.002)
               
}


temporal.repetance.fun <- approxfun(excite.temporal.base, temporal.repetance, 
                                 yleft=1, yright=1)

spatial.repetance.fun <- function(x,y){
    temp <- interp.surface(obj=list(x=excite.spatial.base.x, y=excite.spatial.base.y, z= spatial.repetance), loc=cbind(x=c(x), y=c(y)))
    temp[is.na(temp)]<-0
    temp
}
    
    
   temp.mat <- (1:nrow(a))%o% rep(1, nrow(a))
   ij.mat <- cbind(c(t(temp.mat)), c(temp.mat))
   ij.mat <- ij.mat[a$days[ij.mat[,1]] > a$days[ij.mat[,2]] &a$days[ij.mat[,1]] <= a$days[ij.mat[,2]]+15.0 & abs(a$coorx[ij.mat[,1]] -a$coorx[ij.mat[,2]]) <=2
                 & abs(a$coory[ij.mat[,1]] -a$coory[ij.mat[,2]]) <=2,]                                                          
   excite.wghs <- (A*excite.temporal.fun(a$days[ij.mat[,1]]-a$days[ij.mat[,2]])
     *excite.spatial.fun(a$coorx[ij.mat[,1]]-a$coorx[ij.mat[,2]],a$coory[ij.mat[,1]]-a$coory [ij.mat[,2]])/ lambda.at.events[ij.mat[,1]])
   
   excite.temporal.series <- hist.weighted(a$days[ij.mat[,1]]-a$days[ij.mat[,2]],
                                           excite.wghs/(excite.spatial.edge.correction[ij.mat[,2]]
                                           *temporal.repetance.fun(a$days[ij.mat[,1]]-a$days[ij.mat[,2]])), 
                                           breaks=excite.temporal.base)

excite.temporal.basevalue<- ker.smooth.conv(excite.temporal.series$mids, excite.temporal.series$density, bandwidth=0.05)

excite.temporal.basevalue <- excite.temporal.basevalue/simpson(excite.temporal.basevalue, 0.005) 

plot(excite.temporal.series$mids, excite.temporal.series$density, pch=".",cex=2,col=2)
points(excite.temporal.base, excite.temporal.basevalue,type="l", lwd=2)

save.image('crime-excite-P2.RData')
@ 
<<fig=TRUE>>=
filled.contour(excite.spatial.base.x[seq(1,2001,20)], excite.spatial.base.y[seq(1,2001,20)], spatial.repetance[seq(1,2001,20),seq(1,2001,20)])
@ 
